<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机操作系统 - 死锁</title>
      <link href="/2020/01/18/csnotes-os3/"/>
      <url>/2020/01/18/csnotes-os3/</url>
      
        <content type="html"><![CDATA[<h1 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h1><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png" class="lazyload"></a> </div><br><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h1 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h1><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h1 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h1><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h1 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h1><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><h2 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h2><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" class="lazyload"></a> </div><br><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h2 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h2><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" class="lazyload"></a> </div><br><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h2 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h2><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h1 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h1><p>在程序运行之前预防发生死锁。</p><h2 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h2><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h2 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h2><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h2 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h2><h2 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h2><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h1 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h1><p>在程序运行时避免发生死锁。</p><h2 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h2><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png" class="lazyload"></a> </div><br><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h2 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h2><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" class="lazyload"></a> </div><br><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h2 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h2><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" class="lazyload"></a> </div><br><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS-Notes </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统 - 进程管理</title>
      <link href="/2020/01/18/csnotes-os2/"/>
      <url>/2020/01/18/csnotes-os2/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="1-进程-Process"><a href="#1-进程-Process" class="headerlink" title="1. 进程/Process"></a>1. 进程/Process</h2><p><strong>进程是资源分配的基本单位</strong>。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" class="lazyload"></a> </div><br>## 2. 线程/Thread<p><strong>线程是独立调度的基本单位</strong>。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" class="lazyload"></a> </div><br>## 3. 区别<p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(Inter-Process Communication)。</p><h1 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h1><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" class="lazyload"></a> </div><br>- 就绪状态（ready）：等待被调度- 运行状态（running）- 阻塞状态（waiting）：等待资源<p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h2 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证<u>吞吐量和周转时间</u>（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong>  </p><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong>  </p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong>  </p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h2 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是<u>快速地进行响应</u>。</p><p><strong>2.1 时间片轮转</strong>  </p><p>将所有就绪进程按 <strong>FCFS</strong> 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png" class="lazyload"></a> </div><br>**2.2 优先级调度**  <p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>2.3 多级反馈队列</strong>  </p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png" class="lazyload"></a> </div><br>## 3. 实时系统<p>实时系统要求<u>一个请求在一个确定时间内得到响应</u>。</p><p>分为硬实时(航空航天、军事系统)和软实时(视频点播、日志采集和信息检索系统)，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h2><p><u>对临界资源进行访问的那段代码称为<strong>临界区</strong></u>。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure></div><h2 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h2><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong>，0 表示临界区已经加锁，1 表示临界区解锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><font size="3">   <strong>使用信号量实现生产者-消费者问题</strong>   </font> </p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待，不会释放锁，消费者因此也会永远等待下去。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty); <span class="comment">//down()=0 会使进程睡眠，等待信号量大于0</span></span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">pascal</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure></div><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。</p><p>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size="3">  <strong>使用管程实现生产者-消费者问题</strong>  </font></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">pascal</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><p>生产者和消费者问题前面已经讨论过了。</p><h2 id="1-哲学家进餐问题"><a href="#1-哲学家进餐问题" class="headerlink" title="1. 哲学家进餐问题"></a>1. 哲学家进餐问题</h2><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" class="lazyload"></a> </div><br>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">put</span>((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);         <span class="comment">// 同时拿起两根筷子</span></span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="2-读者-写者问题"><a href="#2-读者-写者问题" class="headerlink" title="2. 读者-写者问题"></a>2. 读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以下内容由 <a href="https://github.com/yugandharbandi" target="_blank" rel="noopener">@Bandi Yugandhar</a> 提供。</p><p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount;                   <span class="comment">//(initial value = 0)</span></span><br><span class="line">semaphore rmutex, wmutex, readLock, resource; <span class="comment">//(initial value = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line"> down(&amp;readLock);                 <span class="comment">//  reader is trying to enter</span></span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//   lock to increase readcount</span></span><br><span class="line">  readcount++;                 </span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)          </span><br><span class="line">   down(&amp;resource);              <span class="comment">//if you are the first reader then lock  the resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release  for other readers</span></span><br><span class="line"> up(&amp;readLock);                 <span class="comment">//Done with trying to access the resource</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//reserve exit section - avoids race condition with readers</span></span><br><span class="line"> readcount--;                       <span class="comment">//indicate you're leaving</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)          <span class="comment">//checks if you are last reader leaving</span></span><br><span class="line">   up(&amp;resource);              <span class="comment">//if last, you must release the locked resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release exit section for other readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &lt;ENTRY Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve entry section for writers - avoids race conditions</span></span><br><span class="line">  writecount++;                <span class="comment">//report yourself as a writer entering</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">1</span>)         <span class="comment">//checks if you're first writer</span></span><br><span class="line">   down(&amp;readLock);            <span class="comment">//if you're first, then you must lock the readers out. Prevent them from trying to enter CS</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release entry section</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"> down(&amp;resource);                <span class="comment">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span></span><br><span class="line">  <span class="comment">//writing is performed</span></span><br><span class="line"> up(&amp;resource);                <span class="comment">//release file</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve exit section</span></span><br><span class="line">  writecount--;                <span class="comment">//indicate you're leaving</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">0</span>)         <span class="comment">//checks if you're the last writer</span></span><br><span class="line">   up(&amp;readLock);               <span class="comment">//if you're last writer, you must unlock the readers. Allows them to try enter CS for reading</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release exit section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p><p>From the both cases we observed that either reader or writer has to starve. Below solution adds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always <u>terminate in a bounded amount of time.</u></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int readCount;                  &#x2F;&#x2F; init to 0; number of readers currently accessing resource</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; all semaphores initialised to 1</span><br><span class="line">Semaphore resourceAccess;       &#x2F;&#x2F; controls access (read&#x2F;write) to the resource</span><br><span class="line">Semaphore readCountAccess;      &#x2F;&#x2F; for syncing changes to shared variable readCount</span><br><span class="line">Semaphore serviceQueue;         &#x2F;&#x2F; FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span><br><span class="line"></span><br><span class="line">void writer()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           &#x2F;&#x2F; wait in line to be servicexs</span><br><span class="line">    &#x2F;&#x2F; &lt;ENTER&gt;</span><br><span class="line">    down(&amp;resourceAccess);         &#x2F;&#x2F; request exclusive access to resource</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           &#x2F;&#x2F; let next in line be serviced</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;WRITE&gt;</span><br><span class="line">    writeResource();            &#x2F;&#x2F; writing is performed</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;WRITE&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;EXIT&gt;</span><br><span class="line">    up(&amp;resourceAccess);         &#x2F;&#x2F; release resource access for next reader&#x2F;writer</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;EXIT&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reader()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           &#x2F;&#x2F; wait in line to be serviced</span><br><span class="line">    down(&amp;readCountAccess);        &#x2F;&#x2F; request exclusive access to readCount</span><br><span class="line">    &#x2F;&#x2F; &lt;ENTER&gt;</span><br><span class="line">    if (readCount &#x3D;&#x3D; 0)         &#x2F;&#x2F; if there are no readers already reading:</span><br><span class="line">        down(&amp;resourceAccess);     &#x2F;&#x2F; request resource access for readers (writers blocked)</span><br><span class="line">    readCount++;                &#x2F;&#x2F; update count of active readers</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           &#x2F;&#x2F; let next in line be serviced</span><br><span class="line">    up(&amp;readCountAccess);        &#x2F;&#x2F; release access to readCount</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;READ&gt;</span><br><span class="line">    readResource();             &#x2F;&#x2F; reading is performed</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;READ&gt;</span><br><span class="line"></span><br><span class="line">    down(&amp;readCountAccess);        &#x2F;&#x2F; request exclusive access to readCount</span><br><span class="line">    &#x2F;&#x2F; &lt;EXIT&gt;</span><br><span class="line">    readCount--;                &#x2F;&#x2F; update count of active readers</span><br><span class="line">    if (readCount &#x3D;&#x3D; 0)         &#x2F;&#x2F; if there are no readers left:</span><br><span class="line">        up(&amp;resourceAccess);     &#x2F;&#x2F; release resource access for all</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;EXIT&gt;</span><br><span class="line">    up(&amp;readCountAccess);        &#x2F;&#x2F; release access to readCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。以下为常见的进程通信机制：</p><h2 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></div><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" class="lazyload"></a> </div><br>## 2. FIFO<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><p>pipe管道，又可以叫做亲族管道，与之对应的则是fifo管道，又可以叫做公共管道。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">// fd:目录路径</span></span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回 0；否则，返回 -1 */</span></span><br></pre></td></tr></table></figure></div><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" class="lazyload"></a> </div><br>## 3. 消息队列<p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h2><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h2 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h2><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h2 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h2><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS-Notes </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统 - 概述</title>
      <link href="/2020/01/18/csnotes-os1/"/>
      <url>/2020/01/18/csnotes-os1/</url>
      
        <content type="html"><![CDATA[<h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h2><p><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h2 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h2><p>共享是指系统中的资源可以被多个<strong>并发进程</strong>共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h2 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><p>程序运行时直接使用物理内存，将不常用的数据写入磁盘(disk)中。</p><h2 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h2><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><h2 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h2><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h2 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h2><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h2 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h2><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img width="600" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" class="lazyload"></a> </div><br>Linux 的系统调用主要有以下这些：<table><thead><tr><th align="center">Task</th><th>Commands</th></tr></thead><tbody><tr><td align="center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td align="center">进程通信</td><td>pipe()创建通信管道; shmget()共享内存函数; mmap()内存映射文件;</td></tr><tr><td align="center">文件操作</td><td>open(); read(); write();</td></tr><tr><td align="center">设备操作</td><td>ioctl()input/output control; read(); write();</td></tr><tr><td align="center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td align="center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h1 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h1><h2 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h2><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h2 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h2><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><div align="center"> <a href="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg" class="lazyload"></a> </div><br># 中断分类<h2 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h2><p>由 CPU 执行指令<strong>以外的事件</strong>引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。</p><p>此外还有时钟中断、控制台中断等。</p><h2 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h2><p>由 CPU 执行指令的<strong>内部事件</strong>引起，如非法操作码、地址越界、算术溢出等。</p><h2 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h2><p>在用户程序中使用系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS-Notes </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记1-AJAX</title>
      <link href="/2020/01/14/note1/"/>
      <url>/2020/01/14/note1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX?"></a>什么是AJAX?</h2><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong></p><h2 id="异步-True-或-False？"><a href="#异步-True-或-False？" class="headerlink" title="异步 - True 或 False？"></a>异步 - True 或 False？</h2><p>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 <strong>true</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajax_test.asp"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div><p>对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。</p><p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p><ul><li>在等待服务器响应时执行其他脚本</li><li>当响应就绪后对响应进行处理</li></ul><p>当使用 <strong>async=true</strong> 时，请规定在响应处于 <strong>onreadystatechange</strong> 事件中的就绪状态时执行的函数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></div><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p>所有现代浏览器均支持<strong>XMLHttpRequest</strong>对象，<strong>XMLHttpRequest</strong>对象用于和服务器交换数据。创建XMLHttpRequest对象的语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></div><p>下面是 XMLHttpRequest 对象的三个重要的属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onreadystatechange</td><td align="left">存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td></tr><tr><td align="left">readyState</td><td align="left">存有 XMLHttpRequest 的状态。 0: 请求未初始化  1: 服务器连接已建立  2: 请求已接收  3: 请求处理中  4: 请求已完成，且响应已就绪</td></tr><tr><td align="left">status</td><td align="left">200: “OK”404: 未找到页面</td></tr></tbody></table><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>HTML页面上的button触发相应的JS函数，</p><p>JS调用服务器页面(php、asp文件)，</p><p>php、asp源代码负责对数据库进行查询，</p><p>然后用HTML表格返回结果</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>XMLHttpRequest</strong> 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"text1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"ajax_test.asp"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>); <span class="comment">//添加HTTP头</span></span><br><span class="line">xmlhttp.send(<span class="string">"fname=Bill&amp;lname=Gates"</span>);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params">url</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> txt,xx,x,i;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    txt=<span class="string">"&lt;table border='1'&gt;&lt;tr&gt;&lt;th&gt;Title&lt;/th&gt;&lt;th&gt;Artist&lt;/th&gt;&lt;/tr&gt;"</span>;</span><br><span class="line">    x=xmlhttp.responseXML.documentElement.getElementsByTagName(<span class="string">"CD"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">      txt=txt + <span class="string">"&lt;tr&gt;"</span>;</span><br><span class="line">      xx=x[i].getElementsByTagName(<span class="string">"TITLE"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">          txt=txt + <span class="string">"&lt;td&gt;"</span> + xx[<span class="number">0</span>].firstChild.nodeValue + <span class="string">"&lt;/td&gt;"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">catch</span> (er)</span><br><span class="line">          &#123;</span><br><span class="line">          txt=txt + <span class="string">"&lt;td&gt; &lt;/td&gt;"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    xx=x[i].getElementsByTagName(<span class="string">"ARTIST"</span>);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">          txt=txt + <span class="string">"&lt;td&gt;"</span> + xx[<span class="number">0</span>].firstChild.nodeValue + <span class="string">"&lt;/td&gt;"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">catch</span> (er)</span><br><span class="line">          &#123;</span><br><span class="line">          txt=txt + <span class="string">"&lt;td&gt; &lt;/td&gt;"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      txt=txt + <span class="string">"&lt;/tr&gt;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    txt=txt + <span class="string">"&lt;/table&gt;"</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'txtCDInfo'</span>).innerHTML=txt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,url,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开题阶段记录</title>
      <link href="/2019/12/26/kt/"/>
      <url>/2019/12/26/kt/</url>
      
        <content type="html"><![CDATA[<h1 id="开题阶段"><a href="#开题阶段" class="headerlink" title="开题阶段"></a>开题阶段</h1><hr><h2 id="PPT初稿"><a href="#PPT初稿" class="headerlink" title="PPT初稿"></a>PPT初稿</h2><blockquote><p>过程中参考的一些网站  </p><ol><li><a href="file:///E:/Downloads/%E5%9F%BA%E4%BA%8EPCA-%E6%A6%82%E7%8E%87%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84P2P%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6.pdf" title="PAC论文1">file:///E:/Downloads/%E5%9F%BA%E4%BA%8EPCA-%E6%A6%82%E7%8E%87%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84P2P%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6.pdf</a></li><li><a href="file:///E:/Downloads/%E5%AE%9E%E6%97%B6%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0_%E6%9F%8F%E9%AA%8F.pdf" title="[PAPER]">file:///E:/Downloads/%E5%AE%9E%E6%97%B6%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0_%E6%9F%8F%E9%AA%8F.pdf</a></li><li><a href="file:///E:/Downloads/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6_%E9%95%87%E4%BD%B3.pdf" title="[PAPER]">file:///E:/Downloads/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6_%E9%95%87%E4%BD%B3.pdf</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-10358-1018088279.htm" target="_blank" rel="noopener" title="[PAPER]">http://cdmd.cnki.com.cn/Article/CDMD-10358-1018088279.htm</a>  </li><li><a href="http://cdmd.cnki.com.cn/article/cdmd-10013-1015527410.htm" target="_blank" rel="noopener" title="[PAPER]">http://cdmd.cnki.com.cn/article/cdmd-10013-1015527410.htm</a>  </li></ol></blockquote><a id="more"></a><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><p>参考别人的思考总结：<a href="https://blog.csdn.net/ajcaizixi/article/details/73916724" target="_blank" rel="noopener">https://blog.csdn.net/ajcaizixi/article/details/73916724</a><br><strong>按照使用的数据特征，目前流量分类可以分为三类：</strong><br>1）基于知名端口分析的方法 不足：动态端口<br>2）基于有效载荷也称数据包分析的方法。通过分析网络协议，基于固定的数据封装格式提取数据特征，专注于在数据包中查找模式或关键字。这类方法仅适用于未加密的流量并且具有高计算开销。不足：协议加密，数据安全，隐私问题等的挑战<br>3）基于流行为特征的方法，1.flow-level;2.packet or datagram-level 不足：效率差</p><p><strong>按照使用的分类方法，可以分为三类：</strong><br>    1）传统的方法 不足：动态端口<br>    2）//基于有效载荷分析的方法，不足：协议加密，数据安全，隐私问题等的挑战<br>    3）使用机器学习的方法， 不足：效率差  </p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ol><li>Moore等人最初描述的数据集(2005)。可以用于对比实验，但是太过陈旧建议使用自己的更有说服力  </li><li>ISCX数据集[3]：分为流特征和原始数据两种格式。原始数据没有标签，第二篇论文作者通过原数据集的描述重新标记了数据得到12类(6类协议封装，6类常规加密)，如下<br><a href="https://i.imgur.com/gPj3Nym.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/gPj3Nym.jpg" class="lazyload" title></a>  </li></ol><h2 id="论文归纳总结"><a href="#论文归纳总结" class="headerlink" title="论文归纳总结"></a>论文归纳总结</h2><blockquote><p>《The Applications of Deep Learning on Traffic Identification》</p></blockquote><p>Z. Wang在2015年首次提出将神将网络和深度学习应用到网络流量分类及异常检测领域。<br>深度学习是指一组基于机器学习的算法集合。在多领域取得成果的深度学习涉及到人工神经网络，比如深度卷积网络、卷积神经网络、深度置信网络和栈式自编码。<br>传统的使用机器学习分类的方法是基于先验知识和数据经验来人为的定义特征和标签，深度学习最显著的优势在于使用表征学习替代手工提取特征的过程，即让模型使用栈式自编码SAE网络结构学习。<br>流量数据和模式识别有一定程度上的相似性。流数据通过处理可以变成图像或者文本数据，每个字节就是一个像素点或者一个字符。 目前已经验证了基于深度学习的模型能够从图像和文本中学习特征用于分类，并且取得了良好的分类效果，因此可以合理认为其在信息安全领域也能表现出优异的性能。<br>特征学习包括特征提取和特征选择，前者是将原始数据空间通过一系列转换映射到新空间，后者是从已有的特征空间中选取子空间，不涉及转换。<br>模型训练就是不断调整优化参数，节点上的权重就是contribution, 通过求和每个节点上的权重可以对byte的重要性排序，结果显示tcp数据中的第1<del>11字节均在top25中，说明在这一区间的byte具有良好的区分度。同时也分析了most useless 300 bytes，这些字节均匀分布在300</del>1000区间。<br>在实验中应用该模型对已知协议的平均分类准确率达到了97.9%，对于未知协议(被传统方法标记为“unknown”)的识别率达到了63.37%。 然而作者实验中仅对未加密流量进行分类实验，对于加密流量该方法的分类效果未知。</p><blockquote><p>《End-to-end Encrypted Traffic Classification with One-dimensional Convolution Neural Networks》</p></blockquote><p>知识点：<br>1.基于ISO/OSI的分层结构, 流量加密技术可以分为应用层加密，表示层加密及网络层加密。应用层加密也称作<strong>常规加密</strong>通常是指应用使用对私有协议对数据进行加解密处理，表示层和网络层加密也称作<strong>协议封装</strong>是指加密整个上层网络的包(TLS,IPsec)。本文研究基于这两种加密方式的进行流量分类。<br>2.这篇文章中对related work归纳总结很好，主要说明使用机器学习的方法，分别有多少篇研究论文使用flow feature、packet feature or both，有哪些使用端到端策略哪些使用分治策略；本文在Dataset中说明了为什么使用self-collected数据，是因为经典机器学习方法需要人工设计特征作为模型输入，所以当前大部分数据集都是特征集而不是原始数据集, 为了提高模型分类结果可信度，使用ISCX作为实验数据集。  </p><p>W. Wang等人提出了基于1D卷积神经网络的端到端加密流量分类方法，相对于分治策略，端到端策略具有更自然的协同效应并且更有可能得到全局最优解，通过将特征提取、特征选择、分类器等多个模块整合在一个框架中, 实现了自动学习从原始输入到期望输出的非线性关系。 作者在协议层面(全七层和第七层基于ISO/OSI模型)和流量表示形式(单向流，双向会话)上进行了四种组合并且通过实验对比得出了最佳组合模式：双向会话+全七层。 作者使用ISCX数据集，与目前最好的分类方法在准确率和召回率进行了对比，结果显示课题提出的方法显著提升了分类性能。然而文中没有说明流或会话长度等参数是如何确定即选择N=784的原因，而且基于我们先验知识以及已有的研究，一般认为网络数据通信过程即包含两个方向，因此四种组合中对流量表示形式的分类没有意义。</p><blockquote><p>《Byte Segment Neural Network for Network Traffic Classification》  </p></blockquote><p>R. Li等人在2018年的IEEE/ACM 26th International Symposium on Quality of Service，IWQoS会议上分享[3]中，提出BSNN模型用于网络流量分类，该模型基于循环神经网络，可以识别分类每个数据报文的协议类型，实验结果显示其在传统协议和复杂的新协议中都表现出了良好的准确性。 但该方法需要根据协议类型将每个数据报文分割成长度不同的segment作为模型的输入，没有考虑流量数据的全局特性，并且该方法仅使用了传统协议流量数据进行对比试验，对于新协议只展示了分类结果且在新协议上的分类准确率远低于传统协议。<br>提出了BSNN(byte Segment neural network)模型用于流量分类。<br>1通过将网络数据报文分割成段，segment然后，segment输入到由具有注意层的RNN单元构成的两级attention注意编码器中。<br>根据报文的特点改进网络结构<br>识别独立数据报文，不需要组装成flow<br>该方法使用单一的数据报文作为模型输入。  </p><p>近年来，深度学习在计算机视觉、语音识别、自然语言处理等多个领域都取得了优异的成果，作者认为网络数据报可以看作是网络应用之间的一种字符语言，因此神经网络在流量分类方面也可能具有良好的性能。<br>里面也提到了网络流前面几个报文的特征是最关键的,以下摘自原文：<br><em>Features  are  collected from  different  levels  of  traffic  and  calculated  on  full flow. Bernaille et. al observed that the size and the direction of the first few packets of the TCP connection are very considerable.According to this, they proposed a model based on simple K-Means [1].</em><br><a href="https://i.imgur.com/C9b544b.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/C9b544b.jpg" class="lazyload" title></a>  </p><blockquote><p>《A novel QUIC traffic Classifier based on Convolutional Neural Networks》  </p></blockquote><p>Van TONG等人在2018年的IEEE Global Communications Conference, GLOBECOM会议上分享[4]中，提出基于CNN的QUIC流量分类器，该方法分别使用基于流和包的特征来提高分类性能。该方法对基于QUIC的五种应用(voice call, chat, video streaming, Google play music and file transfer)按照层次结构模型依次进行二分类和多分类，实验结果显示两个阶段分别取得了99.5%和96%的准确率。然而该方法仅适用于分类基于QUIC协议的网络流量，在基于其他协议上的流量分类没有做出说明，因此认为该方法不具有泛化能力；并且该方法在应用CNN分类之前使用random forest(传统的机器学习方法)进行预分类，增加了模型结构的复杂度。</p><blockquote><p>《Comparison of machine-learning algorithms for classification of VPN network traffic flow using time-related features》</p></blockquote><p>使用时间相关特征识别VPN和non-VPN流量<br>比较6个分类模型的性能(logistic regression, support vector machine, Naïve Bayes, k-nearest, Random Forest classifier,Gradient Boosting Tree)<br>使用ISCX数据集<br>可以借鉴论文写作部分：Model selection and optimisation methods; Statistical metrics; Hyper-parameter optimisation; Bias-variance trade-off</p><h2 id="接下来需要完成的工作"><a href="#接下来需要完成的工作" class="headerlink" title="接下来需要完成的工作"></a>接下来需要完成的工作</h2><ol><li>采集更多的数据，完善数据集 [ssh]</li><li>复现现有分类检测(可能是个大工程)</li><li>可视化byte distribution <strong>[Done]</strong></li><li>撰写开题报告</li><li>注意整理归纳相关的文献</li><li>重构代码结构 <strong>[Done]</strong></li><li>定义评价指标(metrics)  </li><li>学习Go</li><li>开题答辩演练(10mins)</li></ol><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>以下摘自[2]<br>There are several metrics for evaluating our method. Before their definitions, we first introduce <strong>four numbers</strong>.<br>For each protocol in the test set, <strong>True Positives (TP)</strong> means the number of datagrams classified to the specific protocol which indeed belong to the protocol. Let <strong>True Negatives (TN)</strong> be the number of datagrams that are judged as not belonging to the specific protocol and actually not issued by it. <strong>False Positives (FP)</strong> refers to the number of datagrams which is incorrectly classified to the specific protocol. And let <strong>False Negatives (FN)</strong> be the number of datagrams classified to the other protocols but actually generated by the specific application.<br>For evaluation of the test dataset, we define <strong>Precision,Recall and F1</strong> − measure for every target protocols<br><a href="https://i.imgur.com/tVWcs4k.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/tVWcs4k.jpg" class="lazyload" title></a><br>In order to analyze the training phase of BSNN, we use the training loss and the global training accuracy.<br><a href="https://i.imgur.com/vUQ87GS.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/vUQ87GS.jpg" class="lazyload" title></a><br><a href="https://i.imgur.com/nfzcLUs.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/nfzcLUs.jpg" class="lazyload" title></a><br>where K is the number of classes and Total is the total number of instances in the training set. Besides, TP[i] means the TP of class i.</p><p>可以使用loss和accuracy来确定模型<strong>参数</strong>，对比不同参数的收敛速度，一般认为<strong>收敛速度快收敛过程稳定</strong>的情况好。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]L. Bernaille, R. Teixeira, K. Salamatian, “Early application identification,” In Proceedings of the 2006 International Conference on emerging Networking EXperiments and Technologies, Lisboa, Portugal, p. 6, 2006.<br>[2]R. Li, X. Xiao, S. Ni, H. Zheng and S. Xia, “Byte Segment Neural Network for Network Traffic Classification,” 2018 IEEE/ACM 26th International Symposium on Quality of Service (IWQoS), Banff, AB, Canada, 2018, pp. 1-10.<br>[3]ISCX VPN-nonVPN encrypted network traffic dataset. <a href="http://www.unb.ca/cic/research/datasets/vpn.html" target="_blank" rel="noopener">http://www.unb.ca/cic/research/datasets/vpn.html</a>, 2017  </p>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
            <tag> 归纳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习总结</title>
      <link href="/2019/12/25/sx/"/>
      <url>/2019/12/25/sx/</url>
      
        <content type="html"><![CDATA[<h1 id="实习阶段"><a href="#实习阶段" class="headerlink" title="实习阶段"></a>实习阶段</h1><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>银行资料总结(金融知识，行政职业能力测验及申论考试)</li><li>寒假基础知识准备(计算机网络，操作系统，<strong>数据库</strong>sql/redis，数据结构，设计模式，软件工程，<strong>java</strong>，spring框架)</li><li>深入理解java虚拟机(jvm模型，垃圾回收，类加载机制，调优)</li><li>简历准备(互联网/国企，项目)</li><li>算法刷题(剑指2遍，leetcode200)</li><li>github薅项目成为自己的(mall项目)</li><li>在线复习资料(<a href="https://github.com/CyC2018/CS-Notes/blob/master/README.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/README.md</a> <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a>)</li></ol><h2 id="KeyPoint"><a href="#KeyPoint" class="headerlink" title="KeyPoint"></a>KeyPoint</h2><ol><li>国企银行：总行实行&gt;大厂实习&gt;其他    </li><li>国企主要招<strong>后端，测试岗</strong>，<strong>支付宝</strong>类实习有帮助  </li><li>总行金融&gt;数据中心(亲儿子，户口待遇好，加班)？软开=省分行  </li><li>国企准备：<ul><li>简历：<strong>两页</strong>，充分展示自己，排名/保研/党员</li><li>笔试：准备<strong>申论行测</strong>(刷题看书)</li><li>面试：群面(结构化圆桌大家一起讨论要充分体现<strong>理科生逻辑</strong>；半结构化)，自我介绍和兴趣爱好(能上台表演)</li></ul></li><li>国企投递简历技巧：时机(开放投递一两天后)和录取比例  </li><li>国企关注<strong>官网和公众号</strong>的招聘信息</li><li>户口问题：从行业来看，银行》保险〉证券<h2 id="银行部分"><a href="#银行部分" class="headerlink" title="银行部分"></a>银行部分</h2></li></ol><p><strong>中国人民银行</strong>(户口稳，违约金少)</p><ul><li>中国人民银行清算总中心(实习生招聘<a href="http://www.cncc.cn/ryzp/qszzxzp/" target="_blank" rel="noopener">http://www.cncc.cn/ryzp/qszzxzp/</a>)</li><li>中国人民银行金融信息中心</li><li>中国人民银行金融基础数据中心(没有官网招人少)</li><li>中国金融电子化公司(软开) </li></ul><p><strong>中国工商银行</strong></p><ul><li>中国工商银行总行本部</li><li>北分科技菁英计划（提前批）：目标定位为软件研发、信息安全管理、信息系统运营维护等岗位的科技专业人才，新员工录用后，直接安排至分行金融科技部</li><li>中国工商银行牡丹卡中心</li><li>中国工商银行数据中心</li><li>中国工商银行网络金融部创新研发中心</li><li>中国工商银行软件开发中心</li></ul><p><strong>中国银行</strong></p><ul><li><p>总行管培生(信科岗)</p></li><li><p>数据中心</p></li><li><p>软件中心</p></li></ul><p><strong>中国农业银行</strong></p><ul><li>总行</li><li>研发中心</li><li>数据中心</li></ul><p><strong>中国建设银行</strong>(待遇最好)</p><ul><li>总行金融科技部</li></ul><p><strong>交通银行</strong></p><ul><li>。。。</li></ul><p><strong>中国农业发展银行</strong></p><ul><li>总行信息技术岗</li></ul><p>金融公司的FinTech部门核心竞争力就是<strong>配合</strong>（跪舔）销售和投资部门，<strong>平台化/智能化</strong>公司的业务流程</p><h2 id="证券部分"><a href="#证券部分" class="headerlink" title="证券部分"></a>证券部分</h2><p>2020/1/6 何学姐：没有户口？？是指包括券商吗</p><p>比较好的证券公司（中金、中信证券、中信建投、华泰证券）户口：中金》中信建投〉中信证券</p><h2 id="保险部分"><a href="#保险部分" class="headerlink" title="保险部分"></a>保险部分</h2><p>2020/1/6 何学姐：人寿集团统招上机考试，按排名拿户口；泰康北邮本硕都能进</p><p>四大保险公司</p><p>中国人寿、中国人保、中国出口信用保险公司、中国太平</p><p>中国再保险</p><h2 id="运营商部分"><a href="#运营商部分" class="headerlink" title="运营商部分"></a>运营商部分</h2><p>2020/1/6 何学姐：人寿集团统招上机考试，按排名拿户口</p><p>移动》电信〉联通</p><p><strong>中国移动</strong></p><p><strong>中国电信</strong></p><ul><li>电信云待遇不错</li><li>电信总部很好很难进</li><li>电信研究院相对容易发展好位置偏。</li><li>北京电信没有传说中那么好，自负盈亏。</li><li>电信系统集成是不是户口很稳</li><li>总部网运部</li></ul><p><strong>中国联通</strong></p><h2 id="研究院部分"><a href="#研究院部分" class="headerlink" title="研究院部分"></a>研究院部分</h2><p>2020/1/6 何学姐：航天，军工，核能；注重文献学术能力</p><p><strong>铁塔研究院</strong></p><ul><li>14+4k，三年合同</li></ul><p><strong>交通部研究院</strong></p><ul><li>事业编制，到手15w，解决户口</li></ul><p><strong>公安部第一研究所</strong>(公安部网络技术研发中心 &gt; 信息通信中心 = 物证鉴定中心 &gt; 一所、三所)</p><ul><li>java工程师要求：<br>1.Java基本功扎实.熟练使用SSM框架，了解MVC、JPA、OR-Mapping规范的开发思想；<br>2.熟悉Socket通讯、TCP、HTTP协议，了解多线程、高并发技术，熟悉常用的设计模式、数据结构；<br>3.熟练使用Oracle、MySql等数据库，了解NoSql思想，了解数据库中间件思想；<br>4.工作勤劳主动、有责任心、易于沟通，具有团队合作精神<br>5.计算机相关专业</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>中国互联网金融协会</strong></p><p>国家电网比较牛的涉外直属单位</p><p>新华社通信技术局</p><p>中国邮电器材集团公司(分销事业部在复兴门附近)</p><p>中国汽车技术研究中心(天津，央企)</p><h1 id="个人Plan"><a href="#个人Plan" class="headerlink" title="个人Plan"></a>个人Plan</h1><hr><p>Nginx, linux</p><h2 id="职业方向-JAVA开发工程师"><a href="#职业方向-JAVA开发工程师" class="headerlink" title="职业方向-JAVA开发工程师"></a>职业方向-JAVA开发工程师</h2><p><strong>人行软开职位要求</strong>：</p><p>1、熟练掌握Java、J2EE、SQL、XML、HTTP等技术；</p><p>2、熟悉主流数据库系统、应用服务器和开发工具，如Oracle、WebLogic、WebSpheare、JBoss、Tomcat、JBuilder、Eclipse等；</p><p>3、熟悉CVS、Ant、Junit、Spring、Hibernate等OpenSource工具；</p><p>4、熟悉Windows、Linux、Solaris或其它Unix操作系统；</p><p>5、对软件工程过程有基本的了解；</p><p>6、了解RUP或其它过程体系；</p><p>7、至少两年以上的JAVA开发经验；</p><p>8、具有面向对象系统分析和设计的实际经验；</p><p>9、热爱软件设计和开发，积极主动、工作勤奋、细致、踏实，优秀的团队协作能力。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="银行分类图"><a href="#银行分类图" class="headerlink" title="银行分类图"></a>银行分类图</h3><p><a href="https://s2.ax1x.com/2020/01/10/lfOFIS.jpg" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" data-src="https://s2.ax1x.com/2020/01/10/lfOFIS.jpg" class="lazyload" title="avatar"></a></p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归纳 </tag>
            
            <tag> 待完成 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
